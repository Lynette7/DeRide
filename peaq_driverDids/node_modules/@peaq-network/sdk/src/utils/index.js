"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkEvmAddress = exports.generateRandomString = exports.truncatedString = exports.sleep = exports.unsubscribeRuntimeVersion = exports.createStorageKeys = void 0;
const tslib_1 = require("tslib");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const ethers_1 = require("ethers");
const types_1 = require("../types");
const createStorageKeys = (args) => {
    const keysByteArray = [];
    for (let i = 0; i < args.length; i++) {
        if (args[i].type === types_1.CreateStorageKeysEnum.ADDRESS) {
            const decoded_address = (0, util_crypto_1.decodeAddress)(args[i].value, false, 42);
            keysByteArray.push(decoded_address);
        }
        if (args[i].type === types_1.CreateStorageKeysEnum.STANDARD) {
            const hash_name = (0, util_1.u8aToU8a)(args[i].value);
            keysByteArray.push(hash_name);
        }
    }
    const key = (0, util_1.u8aConcat)(...keysByteArray);
    const hashed_key = (0, util_crypto_1.blake2AsHex)(key, 256);
    return { hashed_key };
};
exports.createStorageKeys = createStorageKeys;
const unsubscribeRuntimeVersion = (api) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        api &&
            process.env['NX_ENV'] === 'local' &&
            (yield api.rpc.state.subscribeRuntimeVersion(() => {
                return;
            }))();
    }
    catch (e) {
        console.error('Unsubscribe error: ', e);
    }
});
exports.unsubscribeRuntimeVersion = unsubscribeRuntimeVersion;
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));
exports.sleep = sleep;
const truncatedString = (str) => {
    if (!str)
        return "";
    return (str.substring(0, 7) + "..." + str.substring(str.length - 5, str.length));
};
exports.truncatedString = truncatedString;
const generateRandomString = (length = 6) => {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    for (let i = length; i > 0; --i)
        result += chars[Math.floor(Math.random() * chars.length)];
    return result;
};
exports.generateRandomString = generateRandomString;
/**
 * Used to validate a proper H160 address is being passed.
 */
const checkEvmAddress = (address) => {
    if (!ethers_1.ethers.isAddress(address)) {
        throw new Error(`The address of ${address} is not a valid EVM address`);
    }
};
exports.checkEvmAddress = checkEvmAddress;
//# sourceMappingURL=index.js.map
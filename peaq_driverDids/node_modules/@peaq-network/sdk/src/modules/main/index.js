"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const tslib_1 = require("tslib");
const api_1 = require("@polkadot/api");
const util_crypto_1 = require("@polkadot/util-crypto");
const types_1 = require("../../../../types");
const ethers_1 = require("ethers");
const utils_1 = require("../../utils");
const types_2 = require("../../types");
const base_1 = require("../base");
const did_1 = require("../did");
const rbac_1 = require("../rbac");
const storage_1 = require("../storage");
const ptp_1 = require("../ptp");
/**
 * Main class for interacting with the SDK.
 */
class Main extends base_1.Base {
    constructor(options) {
        super();
        this._options = options;
        this._metadata = {
            "baseUrl": options.baseUrl,
            "chainType": options.chainType
        };
        this._api = this._createApi();
        this.did = new did_1.Did(this._api, this._metadata);
        this.rbac = new rbac_1.RBAC(this._api, this._metadata);
        this.storage = new storage_1.Storage(this._api, this._metadata);
        this.ptp = new ptp_1.Ptp();
    }
    /**
     * Creates a new instance of the SDK and connects to the network.
     *
     * @param CreateInstanceOptions - Options for the SDK with fields:
     *    @param chainType - Used to differentiate between Substrate and EVM txs.
     *    @param baseUrl - RPC url that the API will be connected to.
     *    @param seed - Private key that will sign the transaction.
     * @returns sdk - The SDK built with executable class functions.
     */
    static createInstance(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, util_crypto_1.cryptoWaitReady)();
            const sdk = new Main(options);
            yield sdk.connect();
            return sdk;
        });
    }
    /**
     * Generates a hash of the DID Document without connecting to the chain.
     *
     * @param GenerateDidOptions - The options for generating a DID:
     *    @param address - User address used to construct DID Document.
     *    @param customDocumentFields - Fields that will populate the DID Document.
     *    @param update - Indicates whether you want to build an upgradable DID Document.
     * @returns The hash value of the generated DID document to be stored on chain.
     */
    static generateDidDocument(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const did = new did_1.Did();
            return did.generate(options);
        });
    }
    /**
     * Connects the SDK to the network.
     *
     * If chainType is EVM no connection is established.
     */
    connect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._metadata.chainType == types_2.ChainType.EVM) {
                    return;
                }
                if (!this._api)
                    return;
                yield this._api.isReadyOrError;
                this._validateOptions();
                this._setMetadata();
                !this._api.isConnected && (yield this._api.connect());
            }
            catch (e) {
                throw new Error(`Connection error: ${e}`);
            }
        });
    }
    /**
     * Disconnects the SDK from the wss connected network.
     */
    disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._api && this._api.isConnected) {
                    yield (0, utils_1.unsubscribeRuntimeVersion)(this._api);
                    yield this._api.disconnect();
                }
            }
            catch (e) {
                throw new Error(`Disconnection error: ${e}`);
            }
        });
    }
    /**
     * Checks the seed passed when connecting Substrate.
     */
    _validateOptions() {
        const { seed = '' } = this._options;
        if (seed) {
            const isSeedValid = (0, util_crypto_1.mnemonicValidate)(seed);
            if (!isSeedValid)
                throw new Error('Invalid seed');
        }
    }
    /**
     * Sets the KeyPair in a metadata object so it can be used later
     * to send transactions on behalf of the user.
     */
    _setMetadata() {
        const { seed = '' } = this._options;
        if (seed) {
            const pair = this._getKeyPair(seed);
            this._metadata.pair = pair;
        }
    }
    /**
     * Creates a new instance of the peaq's native Polkadot API connection.
     *
     * @returns undefined - When EVM is set, there is no API connection initialized.
     * @returns ApiPromise - Instance of the Substrate wss connection.
     */
    _createApi() {
        if (this._metadata.chainType == types_2.ChainType.EVM) {
            if (!this._metadata.baseUrl.startsWith("https://")) {
                throw new Error(`Invalid base URL for EVM interactions: ${this._metadata.baseUrl}. It must start with 'https://' to establish RPC connection.`);
            }
            if (this._options.seed) {
                throw new Error("Construction of EVM txs does not require seed/private key. Use the sendEvmTx() to send a transaction on chain with a private key or send manually.");
            }
            return undefined;
        }
        // Sets up a substrate api connection if chain_id is set or undefined (defaults if chainType not set)
        else if (this._metadata.chainType == types_2.ChainType.SUBSTRATE || this._metadata.chainType == undefined) {
            if (!this._metadata.baseUrl.startsWith("wss://")) {
                throw new Error(`Invalid base URL for Substrate interactions: ${this._metadata.baseUrl}. It must start with 'wss://' to establish WSS connection.`);
            }
            const provider = new api_1.WsProvider(this._metadata.baseUrl);
            return new api_1.ApiPromise(Object.assign({ provider, noInitWarn: true }, types_1.defaultOptions));
        }
        else {
            throw new Error("Chain Type not recognized. Please set to either 'evm' or 'substrate' based on what environment you are trying to connect to. No chainType set defaults to substrate.");
        }
    }
    /**
     * Send an EVM transaction on behalf of the user using their funded wallet using their seed/private key.
     *
     * @param SendEvmTx - Object with the parameters:
     *    @param tx - EVM tx object that will be sent to chain. Use sdk to generate peaq txs.
     *    @param baseUrl - RPC url connection to the node that will execute the tx.
     *    @param seed - Private key that will sign the transaction.
     * @returns The receipt of the transaction.
     */
    static sendEvmTx(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { tx, baseUrl, seed } = options;
            if (!tx) {
                throw new Error("Transaction is required for EVM execution.");
            }
            try {
                let provider;
                if (baseUrl.startsWith('wss')) {
                    throw new Error(`Invalid base URL for EVM interactions: ${baseUrl}. It must start with 'https://'.`);
                }
                else if (baseUrl.startsWith('https')) {
                    // JsonRpcProvider for HTTPS URLs
                    provider = new ethers_1.ethers.JsonRpcProvider(baseUrl);
                }
                else {
                    throw new Error(`Invalid base URL for EVM interactions: ${baseUrl}. It must start with 'https://'.`);
                }
                const signer = this._isEvmWalletInputValid(seed, provider);
                const response = yield signer.sendTransaction(tx);
                const receipt = yield response.wait().finally();
                return receipt;
            }
            catch (error) {
                let errorMessage = "";
                // Narrow the error type: check if it's an object with a 'reason' property
                if (error && typeof error === 'object' && 'reason' in error) {
                    errorMessage = error.reason || "";
                }
                else if (error instanceof Error) {
                    errorMessage = error.message;
                }
                else {
                    errorMessage = String(error);
                }
                const regex = /message:\s*Some\("([^"]+)"\)/;
                const match = errorMessage.match(regex);
                const extractedMessage = match ? match[1] : errorMessage;
                throw new Error(`Transaction reverted with error: ${extractedMessage}`);
            }
        });
    }
    /**
    * Builds an EVM wallet for the user to send transactions.
    * Allows for the wallet to be built with a private key or mnemonic phrase.
    *
    * @param key - Private key or seed phrase used to construct the wallet.
    * @param provider - Ethers provider that establishes the sender's connection.
    * @returns The new EVM wallet that will be used to send the tx.
    */
    static _isEvmWalletInputValid(key, provider) {
        try {
            return ethers_1.ethers.Wallet.fromPhrase(key, provider);
        }
        catch (error) {
            try {
                return new ethers_1.ethers.Wallet(key, provider);
            }
            catch (error) {
                throw new Error("Input is neither a valid mnemonic nor a private key");
            }
        }
    }
    /**
     * Subscribes to PTP time synchronization updates
     * @param options - PTP configuration options
     * @param callback - Function to handle synchronization updates
     * @returns Unsubscribe function
     */
    static subscribeToPtp(options, callback) {
        const ptp = new ptp_1.Ptp();
        return ptp.subscribe(options, callback);
    }
}
exports.Main = Main;
Main.ChainType = types_2.ChainType;
//# sourceMappingURL=index.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidClassEvm = void 0;
const tslib_1 = require("tslib");
const peaqDidProto = tslib_1.__importStar(require("peaq-did-proto-js"));
const types_1 = require("../../../../types");
const index_1 = require("./index");
const types_2 = require("../../types");
const util_crypto_1 = require("@polkadot/util-crypto");
const util_1 = require("@polkadot/util");
const utils_1 = require("../../utils");
const api_1 = require("@polkadot/api");
const ethers_1 = require("ethers");
var FunctionSignatures;
(function (FunctionSignatures) {
    FunctionSignatures["ADD_ATTRIBUTE"] = "addAttribute(address,bytes,bytes,uint32)";
    FunctionSignatures["READ_ATTRIBUTE"] = "readAttribute(address,bytes)";
    FunctionSignatures["UPDATE_ATTRIBUTE"] = "updateAttribute(address,bytes,bytes,uint32)";
    FunctionSignatures["REMOVE_ATTRIBUTE"] = "removeAttribute(address,bytes)";
})(FunctionSignatures || (FunctionSignatures = {}));
var PrecompileAddresses;
(function (PrecompileAddresses) {
    PrecompileAddresses["DID"] = "0x0000000000000000000000000000000000000800";
})(PrecompileAddresses || (PrecompileAddresses = {}));
/**
 * Class that builds peaq's DID EVM transactions.
 */
class DidClassEvm {
    constructor(metadata) {
        this.abiCoder = new ethers_1.ethers.AbiCoder();
        this.did = new index_1.Did(undefined, metadata);
        this._metadata = metadata;
    }
    /**
     * Creates a new DID EVM transactions and sends back to the user.
     *
     * @param CreateDidOptions - The parameters this function is expecting:
     *      @param name - The string name of the DID being created
     *      @param address - Address that is used when constructing the DID Document.
     *      @param customDocumentFields - Fields that will populate the DID Document.
     * @returns tx - The transaction object for create DID that a user can send manually.
     */
    create(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { name, address, customDocumentFields } = options;
            const createDidFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ADD_ATTRIBUTE)).substring(0, 10);
            const didAddress = address;
            const didName = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(name));
            const didDocHash = yield this.did.generate({ address, chainType: types_2.ChainType.EVM, customDocumentFields });
            const didVal = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(didDocHash.value));
            const validityFor = 0;
            const params = this.abiCoder.encode(["address", "bytes", "bytes", "uint32"], [didAddress, didName, didVal, validityFor]);
            let payload = params.replace("0x", createDidFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Reads the DID Document at the provided name and address.
     *
     * @param ReadDidOptions - The parameters this function is expecting:
     *      @param name - The name of the DID Document to be read.
     *      @param address - The address where the DID Document is stored.
     * @returns tx - The read DID Document found.
     */
    read(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { name, address, wssBaseUrl } = options;
            return this._storageDecoder(name, address, wssBaseUrl);
        });
    }
    /**
    * Updates a previously created DID Document. Uses the update feature of
    * generate DID Document to ensure proper logic.
    *
    * @param UpdateDidOptions - The parameters this function is expecting:
    *      @param name - Name of the DID to be updated.
    *      @param address - The address where the DID lives.
    *      @param customDocumentFields - New fields that will be updated in the Document. Will overwrite previous data.
    * @returns tx - The transaction object for update DID that a user can send manually.
    */
    update(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { name, address, wssBaseUrl, customDocumentFields } = options;
            const updateDidFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UPDATE_ATTRIBUTE)).substring(0, 10);
            const didAddress = address;
            const didName = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(name));
            // generate an updated DID Document Hash
            const didDocHash = yield this.did.generate({ address, chainType: types_2.ChainType.EVM, wssBaseUrl: wssBaseUrl, customDocumentFields, update: { name: name, value: true } });
            const didVal = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(didDocHash.value));
            const validityFor = 0;
            const params = this.abiCoder.encode(["address", "bytes", "bytes", "uint32"], [didAddress, didName, didVal, validityFor]);
            let payload = params.replace("0x", updateDidFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Removes a DID Document that was previously created at the name and address.
     *
     * @param RemoveDidOptions - The parameters this function is expecting:
     *      @param name - Name of the DID to be removed.
     *      @param address - The address where the DID lives.
     * @returns tx - The transaction object for remove DID that a user can send manually.
     */
    remove(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { name, address } = options;
            this._checkEvmAddress(address);
            const removeDidFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.REMOVE_ATTRIBUTE)).substring(0, 10);
            const didAddress = address;
            const didName = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(name));
            const params = this.abiCoder.encode(["address", "bytes"], [didAddress, didName]);
            let payload = params.replace("0x", removeDidFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Used to validate a proper H160 address is being passed.
     */
    _checkEvmAddress(address) {
        if (!ethers_1.ethers.isAddress(address)) {
            throw new Error(`${address} is not a valid EVM address`);
        }
    }
    _storageDecoder(name, address, wssBaseUrl) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Convert EVM to Substrate address
            if (address == undefined) {
                throw new Error("Address cannot be undefined. Please set to a valid address.");
            }
            if (wssBaseUrl == undefined) {
                throw new Error("wssBaseUrl cannot be undefined. Please set a valid WSS url.");
            }
            const substrateAddress = (0, util_crypto_1.evmToAddress)(address);
            const { hashed_key } = (0, utils_1.createStorageKeys)([
                {
                    value: substrateAddress,
                    type: types_2.CreateStorageKeysEnum.ADDRESS,
                },
                {
                    value: name, type: types_2.CreateStorageKeysEnum.STANDARD
                },
            ]);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const did = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqDid']) === null || _b === void 0 ? void 0 : _b['attributeStore'](hashed_key)));
            yield api.disconnect();
            if (!did || did.isStorageFallback) {
                throw new Error(`Data for the name ${name} at the wss url ${wssBaseUrl} at address ${address} was not found.`);
            }
            const didValue = String(did.toHuman()['value']);
            const document = peaqDidProto.Document.deserializeBinary((0, util_1.hexToU8a)(didValue));
            return Object.assign(Object.assign({}, did.toHuman()), { document: document.toObject() });
        });
    }
    _getApiProvider(wssBaseUrl) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const wsp = new api_1.WsProvider(wssBaseUrl);
                var api = yield (yield api_1.ApiPromise.create(Object.assign({ provider: wsp, noInitWarn: true }, types_1.defaultOptions))).isReady;
                return api;
            }
            catch (error) {
                throw new Error(`Base url of ${wssBaseUrl}, is not valid. It must start with 'wss://' to establish WSS connection to read data.`);
            }
        });
    }
}
exports.DidClassEvm = DidClassEvm;
//# sourceMappingURL=evm_class_did.js.map
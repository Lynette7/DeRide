"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Did = void 0;
const tslib_1 = require("tslib");
const peaqDidProto = tslib_1.__importStar(require("peaq-did-proto-js"));
const util_crypto_1 = require("@polkadot/util-crypto");
const util_1 = require("@polkadot/util");
const utils_1 = require("../../utils");
const errors_1 = require("../../utils/errors");
const types_1 = require("../../types");
const base_1 = require("../base");
const evm_class_did_1 = require("./evm_class_did");
class Did extends base_1.Base {
    constructor(_api, _metadata, _prefix) {
        super();
        this._api = _api;
        this._metadata = _metadata;
        this._prefix = _prefix;
    }
    /**
     * Generates a new DID hash value by creating a DID document with the proto and converting u8a to hex.
     *
     * @param options - The options for generating a DID.
     * @returns value - The hash value of the generated DID document.
     */
    generate(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { address = '', chainType, wssBaseUrl, customDocumentFields, update } = options;
                if (address == undefined) {
                    throw new Error("Address cannot be undefined. Must set a valid address.");
                }
                if (chainType == types_1.ChainType.EVM) {
                    (0, utils_1.checkEvmAddress)(address);
                }
                else {
                    this._checkSubstrateAddress(address);
                }
                let didDocumentHash;
                if (update === null || update === void 0 ? void 0 : update.value) {
                    const readDocument = yield this.read({ name: update.name, address: address, wssBaseUrl: wssBaseUrl });
                    if (!readDocument)
                        throw new errors_1.DidNotFoundError(`DID Document of name ${update.name} for the account address ${address} was not found.`);
                    const oldDocument = readDocument === null || readDocument === void 0 ? void 0 : readDocument.document;
                    didDocumentHash = this._updateDidDocument({
                        didAccountAddress: address,
                        didControllerAddress: address,
                        customDocumentFields: customDocumentFields,
                        oldDocument: oldDocument
                    });
                }
                else {
                    didDocumentHash = this._generateDidDocument({
                        didAccountAddress: address,
                        didControllerAddress: address,
                        customDocumentFields,
                    });
                }
                return {
                    value: didDocumentHash,
                };
            }
            catch (error) {
                throw new errors_1.GenerateDidError(`${error}`);
            }
        });
    }
    /**
     * Creates a new DID by adding a new attribute to the PEAQ DID registry.
     *
     * @param options - The options for creating the DID.
     * @returns CreateDidResult - Contains the block_hash of the executed transaction and unsubscribe() to terminate event listening.
     */
    create(options, statusCallback) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { name, address = '', seed = '', customDocumentFields } = options;
                if (!name)
                    throw new errors_1.NameError('Name is required when creating a DID.');
                if (seed !== '')
                    this._checkSeed(seed);
                // EVM tx logic if chainType is set to EVM
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    // address is required for EVM since it is not stored with the key-pair
                    if (!address)
                        throw new Error("Address is required when creating an EVM transaction since an Account is never stored from seed.");
                    (0, utils_1.checkEvmAddress)(address);
                    const evm = new evm_class_did_1.DidClassEvm(this._metadata);
                    return yield evm.create({ name: name, address: address, customDocumentFields: customDocumentFields });
                }
                // Create and send substrate transaction
                const api = this._getApi();
                if (address !== '')
                    this._checkSubstrateAddress(address);
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const accountAddress = address || keyPair.address;
                const didDocument = this._generateDidDocument({
                    didAccountAddress: accountAddress,
                    didControllerAddress: keyPair.address,
                    customDocumentFields,
                });
                const attributeExtrinsic = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqDid']) === null || _d === void 0 ? void 0 : _d['addAttribute'](accountAddress, name, didDocument, null);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                return {
                    block_hash: (_e = eventData[0]) === null || _e === void 0 ? void 0 : _e.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.CreateDidError(`${error}`);
            }
        });
    }
    /**
     * Reads the attribute of a PEAQ DID from the registry.
     * @param options - The options for reading the DID attribute.
     * @returns A promise that resolves with the DID attribute.
     */
    read(options) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { name, address = '', wssBaseUrl = '' } = options;
                if (!name)
                    throw new Error('Name is required when reading a DID.');
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    if (!address)
                        throw new Error("Address is required when reading an EVM transaction since an Account is never stored from seed.");
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    (0, utils_1.checkEvmAddress)(address);
                    const evm = new evm_class_did_1.DidClassEvm(this._metadata);
                    return yield evm.read({ name: name, address: address, wssBaseUrl: wssBaseUrl });
                }
                const api = this._getApi();
                if (address !== '')
                    this._checkSubstrateAddress(address);
                const accountAddress = address || ((_c = (_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) === null || _c === void 0 ? void 0 : _c.address);
                if (!accountAddress)
                    throw new Error('Address is required');
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: accountAddress,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    { value: name, type: types_1.CreateStorageKeysEnum.STANDARD },
                ]);
                const did = (yield ((_e = (_d = api.query) === null || _d === void 0 ? void 0 : _d['peaqDid']) === null || _e === void 0 ? void 0 : _e['attributeStore'](hashed_key)));
                if (!did || did.isStorageFallback)
                    return null;
                const didValue = String(did.toHuman()['value']);
                const document = peaqDidProto.Document.deserializeBinary((0, util_1.hexToU8a)(didValue));
                return Object.assign(Object.assign({}, did.toHuman()), { document: document.toObject() });
            }
            catch (error) {
                throw new errors_1.ReadDidError(`${error}`);
            }
        });
    }
    /**
     * Updates a previously created DID Document and overwrites the previously set data.
     *
     * @param options: UpdateDidOptions = {address: Address, customDocumentFields?: CustomDocumentFields}
     * @returns UpdateDidResult - Contains log information, block_hash of the executed transaction and unsubscribe() to terminate event listening.
     */
    update(options, statusCallback) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { name, address = '', wssBaseUrl, seed = '', customDocumentFields } = options;
                if (!name)
                    throw new errors_1.NameError('Name is required when updating a DID.');
                if (seed !== '')
                    this._checkSeed(seed);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    if (!address)
                        throw new Error("Address is required when updating an EVM transaction since an Account is never stored from seed.");
                    if (!customDocumentFields)
                        throw new errors_1.NoCustomFieldsError('DID Document fields must be configured before manually changing.');
                    (0, utils_1.checkEvmAddress)(address);
                    const evm = new evm_class_did_1.DidClassEvm(this._metadata);
                    return yield evm.update({ name: name, address: address, wssBaseUrl: wssBaseUrl, customDocumentFields: customDocumentFields });
                }
                const api = this._getApi();
                if (address !== '')
                    this._checkSubstrateAddress(address);
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const accountAddress = address || keyPair.address;
                if (!accountAddress)
                    throw new errors_1.AddressError('Address is required');
                if (!customDocumentFields)
                    throw new errors_1.NoCustomFieldsError('DID Document fields must be configured before manually changing.');
                const readDocument = yield this.read({ name: name, address: accountAddress });
                if (!readDocument)
                    throw new errors_1.DidNotFoundError(`DID Document of name ${name} for the account address ${accountAddress} was not found.`);
                const oldDocument = readDocument === null || readDocument === void 0 ? void 0 : readDocument.document;
                const didDocument = this._updateDidDocument({
                    didAccountAddress: accountAddress,
                    didControllerAddress: keyPair.address,
                    customDocumentFields: customDocumentFields,
                    oldDocument: oldDocument
                });
                const attributeExtrinsic = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqDid']) === null || _d === void 0 ? void 0 : _d['updateAttribute'](accountAddress, name, didDocument, null);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                return {
                    log: `Successfully updated the DID Document of name ${name} at address ${accountAddress}`,
                    block_hash: (_e = eventData[0]) === null || _e === void 0 ? void 0 : _e.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.UpdateDidError(`${error}`);
            }
        });
    }
    /**
     * Removes a previously created DID Document.
     *
     * @param options: UpdateDidOptions = {address: Address, customDocumentFields?: CustomDocumentFields}
     * @returns RemoveDidResult - Contains log information, block_hash of the executed transaction and unsubscribe() to terminate event listening.
     */
    remove(options, statusCallback) {
        var _a, _b, _c, _d, _e, _f, _g;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { name, address = '', seed = '' } = options;
                if (!name)
                    throw new errors_1.NameError('Name is required when removing a DID.');
                if (seed !== '')
                    this._checkSeed(seed);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    if (!address)
                        throw new Error("Address is required when reading an EVM transaction since an Account is never stored from seed.");
                    const evm = new evm_class_did_1.DidClassEvm(this._metadata);
                    return yield evm.remove({ name: name, address: address });
                }
                const api = this._getApi();
                if (address !== '')
                    this._checkSubstrateAddress(address);
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const accountAddress = address || ((_d = (_c = this._metadata) === null || _c === void 0 ? void 0 : _c.pair) === null || _d === void 0 ? void 0 : _d.address);
                if (!accountAddress)
                    throw new errors_1.AddressError('Address is required');
                const readDocument = yield this.read({ name: name, address: accountAddress });
                if (!readDocument)
                    throw new errors_1.DidNotFoundError(`DID Document of name ${name} for the account address ${accountAddress} was not found.`);
                const attributeExtrinsic = (_f = (_e = api.tx) === null || _e === void 0 ? void 0 : _e['peaqDid']) === null || _f === void 0 ? void 0 : _f['removeAttribute'](accountAddress, name);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                // await attributeExtrinsic.signAsync(keyPair, { nonce });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                return {
                    log: `Successfully removed the DID of name ${name} from address ${accountAddress}`,
                    block_hash: (_g = eventData[0]) === null || _g === void 0 ? void 0 : _g.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.RemoveDidError(`${error}`);
            }
        });
    }
    _getDidId(address, prefix) {
        if (prefix == '') {
            return `did:peaq:${address}`;
        }
        return `did:${prefix}:${address}`;
    }
    _createVerificationMethod(verification, didAccountAddress, didControllerAddress, prefix, keyCounter) {
        var _a;
        const verificationMethod = new peaqDidProto.VerificationMethod();
        let id = this._getDidId(didAccountAddress.toString(), prefix);
        id = `${id}#keys-${keyCounter}`;
        verificationMethod.setId(id);
        // If EVM
        if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
            if (verification.type != "EcdsaSecp256k1RecoveryMethod2020") {
                throw new Error(`Verification Type for EVM of ${verification.type} not recognized. Currently only supports method of "EcdsaSecp256k1RecoveryMethod2020" for EVM txs.`);
            }
            verificationMethod.setType(verification.type);
            verificationMethod.setController(didControllerAddress);
            verificationMethod.setPublicKeyMultibase(didAccountAddress); // make sure it is set correctly.
            return { verificationMethod, verificationId: id };
        }
        // Assume it is substrate chain
        if (verification.type == "Ed25519VerificationKey2020") {
            verificationMethod.setType("Ed25519VerificationKey2020");
        }
        else if (verification.type == "Sr25519VerificationKey2020") {
            verificationMethod.setType("Sr25519VerificationKey2020");
        }
        else {
            throw new Error('Invalid type: Type must be either Ed25519VerificationKey2020 or Sr25519VerificationKey2020');
        }
        verificationMethod.setController(didControllerAddress);
        // check to see if use wants to set it manually
        if (verification === null || verification === void 0 ? void 0 : verification.publicKeyMultibase) {
            verificationMethod.setPublicKeyMultibase(verification === null || verification === void 0 ? void 0 : verification.publicKeyMultibase);
        }
        else {
            const publicKey = (0, util_crypto_1.decodeAddress)(didAccountAddress, false, 42);
            const publicKeyHex = (0, util_1.u8aToHex)(publicKey);
            const publicKeyMultibase = publicKeyHex.replace(/^0x/, '');
            verificationMethod.setPublicKeyMultibase(publicKeyMultibase);
        }
        return { verificationMethod, verificationId: id };
    }
    _createSignature(signature) {
        if (!["EcdsaSecp256k1RecoveryMethod2020", "Ed25519VerificationKey2020", "Sr25519VerificationKey2020"].includes(signature.type)) {
            throw new Error('Signature Type must be "EcdsaSecp256k1RecoveryMethod2020", "Ed25519VerificationKey2020" or "Sr25519VerificationKey2020"');
        }
        if (!signature.issuer)
            throw new Error('Signature Issuer is required');
        if (!signature.hash)
            throw new Error('Signature Hash is required');
        const signatureMethod = new peaqDidProto.Signature();
        signatureMethod.setType(signature.type);
        signatureMethod.setIssuer(signature.issuer);
        signatureMethod.setHash(signature.hash);
        return signatureMethod;
    }
    _createService(service) {
        if (!service.id)
            throw new Error('Service ID is required');
        if (!service.type)
            throw new Error('Service type is required');
        if (!(service.serviceEndpoint) && !(service.data))
            throw new Error('Either service endpoint or data is required for service');
        const documentService = new peaqDidProto.Service();
        documentService.setId(service.id);
        documentService.setType(service.type);
        if (service.serviceEndpoint) {
            documentService.setServiceEndpoint(service.serviceEndpoint);
        }
        if (service.data) {
            documentService.setData(service.data);
        }
        return documentService;
    }
    _generateDidDocument(options) {
        const { didAccountAddress, didControllerAddress, customDocumentFields } = options;
        let document = new peaqDidProto.Document();
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.prefix) {
            this._prefix = customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.prefix;
        }
        else { // default to peaq prefix after did: if user doesn't manually set
            this._prefix = 'peaq';
        }
        // set id
        document.setId(this._getDidId(didAccountAddress.toString(), this._prefix));
        // set controller if present in customDocumentFields
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.controller) {
            document = this._setController(customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.controller, document);
        }
        else { // default set controller
            document.setController(this._getDidId(didControllerAddress.toString(), this._prefix));
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.verifications) {
            customDocumentFields.verifications.forEach((verification) => {
                let keyCounter = 1;
                const { verificationId, verificationMethod } = this._createVerificationMethod(verification, didAccountAddress.toString(), document.getController(), this._prefix, keyCounter);
                document.addVerificationMethods(verificationMethod);
                document.addAuthentications(verificationId);
                keyCounter += 1;
            });
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.signature) {
            const signature = customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.signature;
            const documentSignature = this._createSignature(signature);
            document.setSignature(documentSignature);
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.services) {
            customDocumentFields.services.forEach((service) => {
                const documentService = this._createService(service);
                document.addServices(documentService);
            });
        }
        const bytes = document.serializeBinary();
        const hexString = (0, util_1.u8aToHex)(bytes);
        // remove '0x' prefix if present
        const hash = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
        return hash;
    }
    _updateDidDocument(options) {
        const { didAccountAddress, didControllerAddress, customDocumentFields, oldDocument } = options;
        let newDocument = new peaqDidProto.Document();
        const oldId = oldDocument.id;
        const idParts = oldId.split(':');
        // if there is a prefix change id to include that prefix
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.prefix) {
            // only allows the change if current prefix matches what was set beforehand
            if (idParts.length === 3 && idParts[1] === this._prefix) {
                this._prefix = customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.prefix;
                const new_id = `did:${this._prefix}:${idParts[2]}`;
                newDocument.setId(new_id);
            }
        }
        else { // default to previous prefix after did: if user doesn't manually set
            newDocument.setId(oldDocument.id);
            this._prefix = idParts[1];
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.controller) {
            newDocument = this._setController(customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.controller, newDocument);
        }
        else {
            const oldController = oldDocument.controller;
            const controllerParts = oldController.split(':');
            // if the prefix has been changed update the controller to reflect it
            if (this._prefix !== controllerParts[1]) {
                newDocument.setController(`did:${this._prefix}:${controllerParts[2]}`);
            }
            else {
                newDocument.setController(oldDocument.controller);
            }
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.verifications) {
            customDocumentFields.verifications.forEach((verification) => {
                let keyCounter = 1;
                const { verificationId, verificationMethod } = this._createVerificationMethod(verification, didAccountAddress.toString(), newDocument.getController(), this._prefix, keyCounter);
                newDocument.addVerificationMethods(verificationMethod);
                newDocument.addAuthentications(verificationId);
                keyCounter += 1;
            });
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.signature) {
            const signature = customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.signature;
            const documentSignature = this._createSignature(signature);
            newDocument.setSignature(documentSignature);
        }
        if (customDocumentFields === null || customDocumentFields === void 0 ? void 0 : customDocumentFields.services) {
            customDocumentFields.services.forEach((service) => {
                const documentService = this._createService(service);
                newDocument.addServices(documentService);
            });
        }
        const bytes = newDocument.serializeBinary();
        const hexString = (0, util_1.u8aToHex)(bytes);
        // remove '0x' prefix if present
        const hash = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
        return hash;
    }
    _setController(passedController, newDocument) {
        const controllerHold = passedController;
        const controller = `did:${this._prefix}:${controllerHold}`;
        const regexSS58 = /^did:[^:]+:5[1-9A-HJ-NP-Za-km-z]{47}$/;
        const regexETH = /^did:[^:]+:0x[a-fA-F0-9]{40}$/;
        if (!regexSS58.test(controller) && !regexETH.test(controller)) {
            throw new Error('Incorrect controller format. Make sure to set prefix and controller in customDocumentFields. Controller must either be a SS58 or Ethereum Address');
        }
        newDocument.setController(controller);
        return newDocument;
    }
    _checkSeed(seed) {
        const words = seed.trim().split(/\s+/);
        // Check if the length is either 12 or 24
        if (words.length !== 12 && words.length !== 24) {
            throw new errors_1.SeedError('Invalid seed phrase length: Seed phrase must be either 12 or 24 words long.');
        }
    }
    _checkSubstrateAddress(accountAddress) {
        if (!accountAddress)
            throw new errors_1.AddressError('Address is required');
        const regexSS58 = /^[1-9A-HJ-NP-Za-km-z]{48}$/; // regex for ss58
        if (!regexSS58.test(accountAddress)) {
            throw new errors_1.AddressError("Incorrect Substrate SS58 Address format. SS58 address are 58 char in length with 0, O, I & l omitted.");
        }
    }
}
exports.Did = Did;
//# sourceMappingURL=index.js.map
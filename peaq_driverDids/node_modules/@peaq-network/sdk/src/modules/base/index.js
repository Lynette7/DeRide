"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base = void 0;
const tslib_1 = require("tslib");
const util_1 = require("@polkadot/util");
const api_1 = require("@polkadot/api");
class Base {
    constructor(_api) {
        this._api = _api;
        this._getKeyPair = (seed) => {
            if (!seed) {
                throw new Error('Seed is required');
            }
            const keyring = new api_1.Keyring({ ss58Format: 42, type: 'sr25519' });
            return keyring.addFromUri(seed);
        };
        this._nonceStore = new Map();
    }
    _getApi() {
        if (!this._api || !this._api.isConnected)
            throw new Error('API is not connected');
        return this._api;
    }
    _getNonce(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const api = this._getApi();
            const onChainNonce = (yield api.rpc.system.accountNextIndex(address)).toBn();
            const currentNonce = (this._nonceStore.has(address) ? this._nonceStore.get(address) : new util_1.BN(0));
            const nonce = (onChainNonce === null || onChainNonce === void 0 ? void 0 : onChainNonce.gt(currentNonce)) ? onChainNonce : currentNonce;
            const newNonce = nonce === null || nonce === void 0 ? void 0 : nonce.addn(1);
            this._nonceStore.set(address, newNonce);
            return nonce;
        });
    }
    _validateInput(input) {
        const maxLength = 32;
        if (!input) {
            throw new Error("Input is required");
        }
        if (input.length !== maxLength) {
            throw new Error("Input should be 32 length");
        }
        return true;
    }
    _serializeTx(api, tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const methodObject = JSON.parse(tx.method.toString());
            const args = JSON.stringify(methodObject.args);
            const callDecoded = api.registry.findMetaCall(tx.method.callIndex);
            if (callDecoded.method == 'sudo' && callDecoded.method == 'sudo') {
                const sudoCallIndex = tx.method.args[0].callIndex;
                const sudoCallArgs = JSON.stringify(methodObject.args.call.args);
                const sudoCallDecoded = api.registry.findMetaCall(sudoCallIndex);
                return ` (sudo:: ${sudoCallDecoded.section}:: ${sudoCallDecoded.method}(${sudoCallArgs})`;
            }
            else {
                return ` (${callDecoded.section}:: ${callDecoded.method}(${args}))`;
            }
        });
    }
    _transactionError(method, eventData) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const failedEvent = method === 'ExtrinsicFailed';
            const api = this._getApi();
            if (failedEvent) {
                const error = eventData;
                const errorData = (_b = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.toHuman) === null || _b === void 0 ? void 0 : _b.call(_a);
                const errorIdx = (_c = errorData === null || errorData === void 0 ? void 0 : errorData.dispatchError.Module) === null || _c === void 0 ? void 0 : _c.error;
                const moduleIdx = (_d = errorData === null || errorData === void 0 ? void 0 : errorData.dispatchError.Module) === null || _d === void 0 ? void 0 : _d.index;
                if (errorIdx && moduleIdx) {
                    try {
                        const decode = api.registry.findMetaError({
                            error: (0, util_1.isHex)(errorIdx) ? (0, util_1.hexToU8a)(errorIdx) : new util_1.BN(errorIdx),
                            index: new util_1.BN(moduleIdx),
                        });
                        return {
                            documentation: decode.docs,
                            name: decode.name,
                            section: decode.section
                        };
                    }
                    catch (error) {
                        return {
                            documentation: ['Unknown error'],
                            name: 'UnknownError',
                            section: 'UnknownSection'
                        };
                    }
                }
            }
            else {
                return {
                    documentation: ['Unknown error'],
                    name: 'UnknownError',
                    section: 'UnknownSection'
                };
            }
            return null;
        });
    }
    _newSignTx(option) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                const { extrinsics, nonce, address, statusCallback } = option;
                const api = this._getApi();
                let subscribed = false;
                try {
                    // Sign the transaction
                    yield extrinsics.signAsync(address, { nonce });
                }
                catch (error) {
                    reject(error);
                }
                try {
                    // Send the transaction and listen for events
                    const unsub = yield extrinsics.send((result) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        statusCallback === null || statusCallback === void 0 ? void 0 : statusCallback(result);
                        if ((result.status.isInBlock || result.status.isFinalized) &&
                            !subscribed) {
                            // Handle transaction inclusion
                            subscribed = true;
                            let inclusionBlockHash;
                            if (result.status.isInBlock) {
                                inclusionBlockHash = result.status.asInBlock.toString();
                            }
                            if (result.status.isFinalized) {
                                inclusionBlockHash = result.status.asFinalized.toString();
                            }
                            // Get inclusion block details
                            const inclusionBlockHeader = yield api.rpc.chain.getHeader(inclusionBlockHash);
                            const inclusionBlockNr = inclusionBlockHeader.number.toBn();
                            const executionBlockStartNr = inclusionBlockNr.addn(0);
                            const executionBlockStopNr = inclusionBlockNr.addn(10);
                            let executionBlockNr = executionBlockStartNr;
                            // save instance of current block hash for peaqEvent
                            const _inclusionBlockHash = inclusionBlockHash;
                            // Subscribe to new blocks
                            const unsubscribeNewHeads = yield api.rpc.chain.subscribeNewHeads((lastHeader) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                                const lastBlockNumber = lastHeader.number.toBn();
                                if (executionBlockNr.gt(executionBlockStopNr)) {
                                    // Transaction not executed within expected blocks
                                    unsubscribeNewHeads();
                                    reject(`Tx([${extrinsics.hash.toString()}]) was not executed in blocks: ${executionBlockStartNr.toString()}..${executionBlockStopNr.toString()}`);
                                    unsub();
                                    return;
                                }
                                if (lastBlockNumber.gte(executionBlockNr)) {
                                    const blockHash = yield api.rpc.chain.getBlockHash(executionBlockNr);
                                    const blockHeader = yield api.rpc.chain.getHeader(blockHash);
                                    const extinsics = (yield api.rpc.chain.getBlock(blockHeader.hash)).block.extrinsics;
                                    executionBlockNr.iaddn(1);
                                    const index = extinsics.findIndex((extrinsic) => {
                                        return (extrinsic.hash.toString() === extrinsics.hash.toString());
                                    });
                                    if (index < 0) {
                                        return;
                                    }
                                    else {
                                        unsubscribeNewHeads();
                                    }
                                    const events = yield result.events;
                                    const peaqEvents = events.map(({ event, phase }) => {
                                        const { data, method, section } = event;
                                        const eventData = { lookupName: method, data: data };
                                        return {
                                            event: event,
                                            phase: phase,
                                            section: section,
                                            method: method,
                                            eventData: [eventData],
                                            blockHash: _inclusionBlockHash
                                        };
                                    });
                                    // check for any failed extrinsics
                                    const extrinsicFailedEvents = peaqEvents.filter(peaqEvent => peaqEvent.method === "ExtrinsicFailed");
                                    if (extrinsicFailedEvents.length > 0) {
                                        const eventData = extrinsicFailedEvents[0].eventData[0];
                                        const errorResp = yield this._transactionError(extrinsicFailedEvents[0].method, eventData);
                                        reject(new Error(`${errorResp === null || errorResp === void 0 ? void 0 : errorResp.name} for ${errorResp === null || errorResp === void 0 ? void 0 : errorResp.section}.`));
                                    }
                                    resolve(peaqEvents);
                                    unsub();
                                }
                            }));
                        }
                        if (result.isError) {
                            console.info('Transaction Error Result', JSON.stringify(result, null, 2));
                            reject(`Tx([${extrinsics.hash.toString()}]) Transaction error`);
                        }
                    }));
                }
                catch (error) {
                    reject({
                        data: error.message ||
                            error.description ||
                            ((_a = error.data) === null || _a === void 0 ? void 0 : _a.toString()) ||
                            error.toString(),
                    });
                }
            }));
        });
    }
}
exports.Base = Base;
//# sourceMappingURL=index.js.map
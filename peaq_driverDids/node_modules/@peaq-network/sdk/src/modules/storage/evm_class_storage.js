"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageClassEvm = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const util_crypto_1 = require("@polkadot/util-crypto");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const api_1 = require("@polkadot/api");
const types_2 = require("../../../../types");
var FunctionSignatures;
(function (FunctionSignatures) {
    FunctionSignatures["ADD_ITEM"] = "addItem(bytes,bytes)";
    FunctionSignatures["GET_ITEM"] = "getItem(address,bytes)";
    FunctionSignatures["UPDATE_ITEM"] = "updateItem(bytes,bytes)";
    FunctionSignatures["REMOVE_ITEM"] = "removeItem(bytes)"; // appears to not exist in the precompiles
})(FunctionSignatures || (FunctionSignatures = {}));
var PrecompileAddresses;
(function (PrecompileAddresses) {
    PrecompileAddresses["STORAGE"] = "0x0000000000000000000000000000000000000801";
})(PrecompileAddresses || (PrecompileAddresses = {}));
/**
 * Class that builds peaq's Storage EVM transactions.
 */
class StorageClassEvm {
    constructor() {
        this.abiCoder = new ethers_1.ethers.AbiCoder();
    }
    /**
     * Adds a new item to peaq storage.
     *
     * @param AddItemOptions - The parameters this function is expecting:
     *      @param itemType - The key at which the value is stored.
     *      @param item - The value which is mapped to the itemType key.
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    addItem(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { itemType, item } = options;
            const createStorageFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ADD_ITEM)).substring(0, 10);
            const itemTypeBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(itemType));
            const itemString = typeof item === 'string' ? item : JSON.stringify(item);
            const itemBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(itemString));
            const params = this.abiCoder.encode(["bytes", "bytes"], [itemTypeBytes, itemBytes]);
            let payload = params.replace("0x", createStorageFunctionSelector);
            const tx = {
                to: PrecompileAddresses.STORAGE,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Removes an item from peaq storage.
     *
     * @param RemoveItemOptions - The parameters this function is expecting:
     *      @param itemType - The key at which the value is stored that will be deleted.
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    removeItem(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { itemType } = options;
            const deleteStorageFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.REMOVE_ITEM)).substring(0, 10);
            const itemTypeBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(itemType));
            const params = this.abiCoder.encode(["bytes"], [itemTypeBytes]);
            let payload = params.replace("0x", deleteStorageFunctionSelector);
            const tx = {
                to: PrecompileAddresses.STORAGE,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Reads an item from peaq storage using storage keys.
     *
     * @param GetItemOptions - The parameters this function is expecting:
     *      @param itemType - The key at which the value is stored that will be read.
     *      @param address - The address which holds the storage of itemType.
     * @returns - Read storage item.
     */
    getItem(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { itemType, address, wssBaseUrl } = options;
            this._checkEvmAddress(address);
            return yield this._storageDecoder(itemType, address, wssBaseUrl);
        });
    }
    /**
     * Adds a new item to peaq storage.
     *
     * @param UpdateItemOptions - The parameters this function is expecting:
     *      @param itemType - The key at which the value is stored.
     *      @param item - The value which is mapped to the itemType key to be updated.
     * @returns tx - The transaction object for update item that a user can send manually.
     */
    updateItem(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { itemType, item } = options;
            const createStorageFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UPDATE_ITEM)).substring(0, 10);
            const itemTypeBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(itemType));
            const itemString = typeof item === 'string' ? item : JSON.stringify(item);
            const itemBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(itemString));
            const params = this.abiCoder.encode(["bytes", "bytes"], [itemTypeBytes, itemBytes]);
            let payload = params.replace("0x", createStorageFunctionSelector);
            const tx = {
                to: PrecompileAddresses.STORAGE,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Used to validate a proper H160 address is being passed.
     */
    _checkEvmAddress(address) {
        if (!ethers_1.ethers.isAddress(address)) {
            throw new Error(`${address} is not a valid EVM address`);
        }
    }
    _storageDecoder(itemType, address, wssBaseUrl) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Convert EVM to Substrate address
            if (address == undefined) {
                throw new Error("Address cannot be undefined. Please set to a valid address.");
            }
            if (wssBaseUrl == undefined) {
                throw new Error("wssBaseUrl cannot be undefined. Please set a valid WSS url.");
            }
            const substrateAddress = (0, util_crypto_1.evmToAddress)(address);
            const { hashed_key } = (0, utils_1.createStorageKeys)([
                {
                    value: substrateAddress,
                    type: types_1.CreateStorageKeysEnum.ADDRESS,
                },
                {
                    value: itemType, type: types_1.CreateStorageKeysEnum.STANDARD
                },
            ]);
            // init the api connection
            const api = yield this._getApiProvider(wssBaseUrl);
            const item = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqStorage']) === null || _b === void 0 ? void 0 : _b['itemStore'](hashed_key)));
            yield api.disconnect();
            if (item.toHuman() == '') {
                throw new Error(`Data for the name ${name} at the wss url ${wssBaseUrl} at address ${address} was not found.`);
            }
            return {
                [itemType]: `${item.toHuman()}`,
            };
        });
    }
    _getApiProvider(wssBaseUrl) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const wsp = new api_1.WsProvider(wssBaseUrl);
                var api = yield (yield api_1.ApiPromise.create(Object.assign({ provider: wsp, noInitWarn: true }, types_2.defaultOptions))).isReady;
                return api;
            }
            catch (error) {
                throw new Error(`WSS base url of ${wssBaseUrl}, is not valid with error message: ${error}`);
            }
        });
    }
}
exports.StorageClassEvm = StorageClassEvm;
//# sourceMappingURL=evm_class_storage.js.map
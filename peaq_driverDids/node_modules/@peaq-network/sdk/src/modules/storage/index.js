"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Storage = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const util_1 = require("@polkadot/util");
const errors_1 = require("../../utils/errors");
const base_1 = require("../base");
const evm_class_storage_1 = require("./evm_class_storage");
class Storage extends base_1.Base {
    constructor(_api, _metadata) {
        super();
        this._api = _api;
        this._metadata = _metadata;
    }
    /**
     * Adds item to peaqStorage
     *
     * TODO Determine what constraints we need to establish before adding to storage
     */
    addItem(options, statusCallback) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { itemType, item, seed = '' } = options;
                if (!itemType)
                    throw new errors_1.ItemTypeError('Item Type name is required');
                if (!item)
                    throw new errors_1.ItemError('Item name is required');
                if (seed !== '')
                    this._checkSeed(seed);
                const itemString = typeof item === 'string' ? item : JSON.stringify(item);
                if ((0, util_1.stringToU8a)(itemType).length > 64)
                    throw new errors_1.ItemTypeError('New Item Type cannot be larger than 64 bytes');
                if ((0, util_1.stringToU8a)(itemString).length > 256)
                    throw new errors_1.ItemError('New Item cannot be larger than 256 bytes');
                // EVM tx logic if chainType is set to EVM
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    const evm = new evm_class_storage_1.StorageClassEvm();
                    return yield evm.addItem({ itemType: itemType, item: itemString });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const attributeExtrinsic = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqStorage']) === null || _d === void 0 ? void 0 : _d['addItem'](itemType, itemString);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                // is it necessary to add more verbose logging in return object?
                return {
                    message: `Successfully added the storage item type ${itemType} with item ${itemString} for the address ${keyPair.address}`,
                    block_hash: (_e = eventData[0]) === null || _e === void 0 ? void 0 : _e.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.StorageError(`${error}`);
            }
        });
    }
    /**
     * Removes the itemType in peaqStorage
     */
    removeItem(options, statusCallback) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { itemType, seed = '' } = options;
                if (!itemType)
                    throw new errors_1.ItemTypeError('Item Type name is required');
                if (seed !== '')
                    this._checkSeed(seed);
                // Needs removeItem() to be added to precompile
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    throw new Error("Remove item for EVM currently being developed.");
                    // const evm = new StorageClassEvm();
                    // return await evm.removeItem({itemType: itemType})
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const attributeExtrinsic = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqStorage']) === null || _d === void 0 ? void 0 : _d['removeItem'](itemType);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                // await attributeExtrinsic.signAsync(keyPair, { nonce });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                // successfully removed the did of name __ from address machine address __
                return {
                    message: `Successfully removed the storage item type ${itemType} from address ${keyPair.address}`,
                    block_hash: (_e = eventData[0]) === null || _e === void 0 ? void 0 : _e.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.StorageError(`${error}`);
            }
        });
    }
    getItem(options) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { itemType, address = '', wssBaseUrl = '' } = options;
                if (!itemType)
                    throw new errors_1.ItemTypeError('Item Type name is required');
                // EVM tx logic if chainType is set to EVM
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    if (!address)
                        throw new Error("Address is required when reading from peaq EVM storage.");
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_storage_1.StorageClassEvm();
                    return yield evm.getItem({ itemType: itemType, address: address, wssBaseUrl: wssBaseUrl });
                }
                const api = this._getApi();
                if (address !== '')
                    this._checkAddress(address);
                const accountAddress = address || ((_c = (_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) === null || _c === void 0 ? void 0 : _c.address);
                if (!accountAddress)
                    throw new errors_1.StorageAddressError('Address is required');
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: accountAddress,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: itemType, type: types_1.CreateStorageKeysEnum.STANDARD
                    },
                ]);
                const item = (yield ((_e = (_d = api.query) === null || _d === void 0 ? void 0 : _d['peaqStorage']) === null || _e === void 0 ? void 0 : _e['itemStore'](hashed_key)));
                if (!item || item.isStorageFallback)
                    return null;
                // is toHuman acceptable here? What if a simple string is not passed?
                return {
                    [itemType]: `${item.toHuman()}`,
                };
            }
            catch (error) {
                throw new errors_1.StorageError(`${error}`);
            }
        });
    }
    updateItem(options, statusCallback) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { itemType, item, seed = '' } = options;
                // checks
                if (!itemType)
                    throw new errors_1.ItemTypeError('Item Type name is required');
                if (!item)
                    throw new errors_1.ItemError('Item name is required');
                if (seed !== '')
                    this._checkSeed(seed);
                const itemString = typeof item === 'string' ? item : JSON.stringify(item);
                if ((0, util_1.stringToU8a)(itemType).length > 64)
                    throw new errors_1.ItemTypeError('New Item Type cannot be larger than 64 bytes');
                if ((0, util_1.stringToU8a)(itemString).length > 256)
                    throw new errors_1.ItemError('New Item cannot be larger than 256 bytes');
                // EVM tx logic if chainType is set to EVM
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_1.ChainType.EVM) {
                    const evm = new evm_class_storage_1.StorageClassEvm();
                    return yield evm.updateItem({ itemType: itemType, item: itemString });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const attributeExtrinsic = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqStorage']) === null || _d === void 0 ? void 0 : _d['updateItem'](itemType, itemString);
                const nonce = yield this._getNonce(keyPair.address);
                const eventData = yield this._newSignTx({ nonce, address: keyPair, extrinsics: attributeExtrinsic });
                const unsubscribe = yield attributeExtrinsic.send((result) => {
                    statusCallback &&
                        statusCallback(result);
                });
                // is it necessary to add more verbose logging in return object?
                return {
                    message: `Successfully updated the storage item type ${itemType} to the new item ${itemString} for the address ${keyPair.address}`,
                    block_hash: (_e = eventData[0]) === null || _e === void 0 ? void 0 : _e.blockHash,
                    unsubscribe,
                };
            }
            catch (error) {
                throw new errors_1.StorageError(`${error}`);
            }
        });
    }
    // same code as fund in did/inxdex.ts -> eventually put into a file that uses the same code in different places
    _checkSeed(seed) {
        const words = seed.trim().split(/\s+/);
        // Check if the length is either 12 or 24
        if (words.length !== 12 && words.length !== 24) {
            throw new errors_1.StorageSeedError('Invalid seed phrase length: Seed phrase must be either 12 or 24 words long.');
        }
    }
    // same code as fund in did/inxdex.ts -> eventually put into a file that uses the same code in different places
    _checkAddress(accountAddress) {
        const regexSS58 = /^[1-9A-HJ-NP-Za-km-z]{48}$/; // regex for ss58
        const regexETH = /^0x[a-fA-F0-9]{40}$/; // regex for Ethereum
        if (!regexSS58.test(accountAddress) && !regexETH.test(accountAddress)) {
            throw new errors_1.StorageAddressError(`Incorrect Substrate SS58/Ethereum Address format. Given address does not match expected length or contains an invalid char. 
            SS58 address are 58 char in length with 0, O, I & l omitted. Ethereum addresses are 42 characters in length, starting with "0x" followed by 
            40 hexadecimal characters (0-9, a-f, A-F) with no characters omitted.`);
        }
    }
}
exports.Storage = Storage;
//# sourceMappingURL=index.js.map
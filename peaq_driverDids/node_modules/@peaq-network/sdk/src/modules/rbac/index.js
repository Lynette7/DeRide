"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RBAC = void 0;
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const types_1 = require("../../types");
const base_1 = require("../base");
const utils_1 = require("../../utils");
const util_1 = require("@polkadot/util");
const types_2 = require("../../types");
const evm_class_rbac_1 = require("./evm_class_rbac");
class RBAC extends base_1.Base {
    constructor(_api, _metadata) {
        super();
        this._api = _api;
        this._metadata = _metadata;
    }
    /**
     * Creates a new role of the given name at the role id. User may manually set role id
     * but it must be equal to 32 bytes.
     *
     * @param CreateRole - Create Role object parameter expecting:
     *      @param roleName - Name of the role that is created
     *      @param roleId? - Generate/user created role ID that acts as the key
     *      @param address? - Address to send the tx; defaults to use address at seed.
     *      @param seed? - If not set at create_instance, used to get a keypair to send txs.
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createRole(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { roleName, roleId = '', address = '', seed = '' } = options;
                if (!roleName)
                    throw new Error('Name is required');
                if (roleId && roleId.length !== 32)
                    throw new Error('Role Id length should be 32 char only');
                const generatedRoleId = (0, uuid_1.v4)().slice(0, 32);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    const tx = yield evm.createRole({ roleName: roleName, roleId: roleId || generatedRoleId });
                    return { tx: tx, roleId: roleId || generatedRoleId };
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const convertedRoleId = (0, util_1.stringToU8a)(roleId || generatedRoleId);
                const addRoleExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['addRole'](convertedRoleId, roleName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: addRoleExtrinsics,
                });
                return {
                    roleId: roleId || generatedRoleId,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while creating roles: ${error}`);
            }
        });
    }
    /**
     * Creates a new group of the given name at the group id. User may manually set group id
     * but it must be equal to 32 bytes.
     *
     * @param CreateGroup - Create Group object parameter expecting:
     *      @param groupName - Name of the group that is created
     *      @param groupId? - Generate/user created group ID that acts as the key.
     *      @param address? - Address to send the tx; defaults to use address at seed.
     *      @param seed? - If not set at create_instance, used to get a keypair to send txs.
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createGroup(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupName, groupId = '', address = '', seed = '' } = options;
                if (!groupName)
                    throw new Error('Name is required');
                if (groupId && groupId.length !== 32)
                    throw new Error('Group Id length should be 32 char only');
                const generatedGroupId = (0, uuid_1.v4)().slice(0, 32);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    const tx = yield evm.createGroup({ groupName: groupName, groupId: groupId || generatedGroupId });
                    return { tx: tx, groupId: groupId || generatedGroupId };
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const convertedGroupId = (0, util_1.stringToU8a)(groupId || generatedGroupId);
                const addGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['addGroup'](convertedGroupId, groupName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: addGroupExtrinsics,
                });
                return {
                    groupId: groupId || generatedGroupId,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while creating group: ${error}`);
            }
        });
    }
    /**
     * Creates a new permission of the given name at the permission id. User may manually set permission id
     * but it must be equal to 32 bytes.
     *
     * @param CreatePermission - Create permission object parameter expecting:
     *      @param permissionName - Name of the permission that is created
     *      @param permissionId? - Generate/user created permission ID that acts as the key.
     *      @param address? - Address to send the tx; defaults to use address at seed.
     *      @param seed? - If not set at create_instance, used to get a keypair to send txs.
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createPermission(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { permissionName, permissionId = '', address = '', seed = '', } = options;
                if (!permissionName)
                    throw new Error('Name is required');
                if (permissionId && permissionId.length !== 32)
                    throw new Error('Permission Id length should be 32 char only');
                const generatedPermissionId = (0, uuid_1.v4)().slice(0, 32);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    const tx = yield evm.createPermission({ permissionName: permissionName, permissionId: permissionId || generatedPermissionId });
                    return { tx: tx, permissionId: permissionId || generatedPermissionId };
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const convertedPermissionId = (0, util_1.stringToU8a)(permissionId || generatedPermissionId);
                const addPermissionExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['addPermission'](convertedPermissionId, permissionName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: addPermissionExtrinsics,
                });
                return {
                    permissionId: permissionId || generatedPermissionId,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while creating permission: ${error}`);
            }
        });
    }
    /** UPDATE
     *
     * Assign permission to role.
     * @param options - The options for assigning permission to role.
     * @returns A promise that resolves when the permission is assign to role.
     */
    assignPermissionToRole(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { address = '', seed = '', permissionId, roleId } = options;
                this._validateInput(permissionId);
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.assignPermissionToRole({ permissionId: permissionId, roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const assignPermissionToRoleExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['assignPermissionToRole']((0, util_1.stringToU8a)(permissionId), (0, util_1.stringToU8a)(roleId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: assignPermissionToRoleExtrinsics,
                });
                return {
                    message: `Successfully assign permission ${permissionId} to role ${roleId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while assign permission to role: ${error}`);
            }
        });
    }
    /** UPDATE
     *
     * Assign role to group.
     * @param options - The options for assigning role to group.
     * @returns A promise that resolves when the role is assign to group.
     */
    assignRoleToGroup(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupId, roleId, address = '', seed = '' } = options;
                this._validateInput(groupId);
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.assignRoleToGroup({ groupId: groupId, roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const assignRoleToGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['assignRoleToGroup']((0, util_1.stringToU8a)(roleId), (0, util_1.stringToU8a)(groupId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: assignRoleToGroupExtrinsics,
                });
                return {
                    message: `Successfully assign role ${roleId} to group ${groupId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while assign role to group: ${error}`);
            }
        });
    }
    /**
     * UPDATE
     *
     * Assign role to user.
     * @param options - The options for assigning role to user.
     * @returns A promise that resolves when the role is assign to user.
     */
    assignRoleToUser(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, roleId, address = '', seed = '', } = options;
                this._validateInput(userId);
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.assignRoleToUser({ userId: userId, roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const assignRoleToUserExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['assignRoleToUser']((0, util_1.stringToU8a)(roleId), (0, util_1.stringToU8a)(userId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: assignRoleToUserExtrinsics,
                });
                return {
                    message: `Successfully assign role ${roleId} to user ${userId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while assign role to user: ${error}`);
            }
        });
    }
    /** UPDATE
     *
     *
     * Assign user to group.
     * @param options - The options for assigning user to group.
     * @returns A promise that resolves when the user is assign to group.
     */
    assignUserToGroup(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, groupId, address = '', seed = '' } = options;
                this._validateInput(userId);
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.assignUserToGroup({ userId: userId, groupId: groupId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const assignUserToGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['assignUserToGroup']((0, util_1.stringToU8a)(userId), (0, util_1.stringToU8a)(groupId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: assignUserToGroupExtrinsics,
                });
                return {
                    message: `Successfully assign user ${userId} to group ${groupId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while assign user to group: ${error}`);
            }
        });
    }
    /**
     * Disable the group.
     * @param options - The options for disable the group.
     * @returns A promise that resolves when group is disable.
     */
    disableGroup(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupId, address = '', seed = '' } = options;
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.disableGroup({ groupId: groupId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const disableGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['disableGroup']((0, util_1.stringToU8a)(groupId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: disableGroupExtrinsics,
                });
                return {
                    message: `Successfully disable group ${groupId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while disable group: ${error}`);
            }
        });
    }
    /**
     * Disable the permission.
     * @param options - The options for disable the permission.
     * @returns A promise that resolves when permission is disable.
     */
    disablePermission(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { permissionId, address = '', seed = '' } = options;
                this._validateInput(permissionId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.disablePermission({ permissionId: permissionId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const disableGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['disablePermission']((0, util_1.stringToU8a)(permissionId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: disableGroupExtrinsics,
                });
                return {
                    message: `Successfully disable permission ${permissionId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while disable permission: ${error}`);
            }
        });
    }
    /**
     * Disable the role.
     * @param options - The options for disable the role.
     * @returns A promise that resolves when role is disable.
     */
    disableRole(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { roleId, address = '', seed = '' } = options;
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.disableRole({ roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const disableGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['disableRole']((0, util_1.stringToU8a)(roleId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: disableGroupExtrinsics,
                });
                return {
                    message: `Successfully disable role ${roleId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while disable role: ${error}`);
            }
        });
    }
    /**
     * Fetches all of the roles this user address has.
     *
     * @param FetchRoles - The parameters this function is expecting:
     *      @param owner - Address that owns all of the roles.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchRoles(options) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, wssBaseUrl = '' } = options;
                if (!owner)
                    throw new Error('Invalid owner address');
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchRoles({ owner: owner, wssBaseUrl: wssBaseUrl });
                }
                const api = this._getApi();
                const roles = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['roleStore'](owner)));
                if (!roles) {
                    throw new Error(`Roles not exits with this owner address = ${owner}`);
                }
                const responseData = roles === null || roles === void 0 ? void 0 : roles.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return responseData;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching roles: ${error}`);
            }
        });
    }
    /**
     * Fetches the Group for the owner at the groupId.
     *
     * @param FetchGroup - The parameters this function is expecting:
     *      @param owner - Address that owns this particular group.
     *      @param groupId? - Specific group identifier that will be fetched.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchGroup(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupId, owner, wssBaseUrl = '' } = option;
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!owner)
                        throw new Error("Address is required when reading an EVM transaction since an Account is never stored from seed.");
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchGroup({ owner: owner, groupId: groupId, wssBaseUrl: wssBaseUrl });
                }
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: groupId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'Group',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const api = this._getApi();
                const groups = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['keysLookUpStore'](hashed_key)));
                if (!groups) {
                    throw new Error(`Group not exits with this owner address = ${owner}`);
                }
                const { id, name, enabled } = JSON.parse(JSON.stringify(groups.toHuman()));
                if (!name) {
                    throw new Error(`Group not exits with this owner address = ${owner}`);
                }
                return {
                    id,
                    name,
                    enabled,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while fetching group: ${error}`);
            }
        });
    }
    /**
     * Fetch all group permission.
     * @param option - The option for fetch group permissions.
     * @returns A promise that resolves when the group permission is fetched.
     */
    fetchGroupPermissions(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupId, owner, wssBaseUrl = '' } = option;
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchGroupPermissions({ owner: owner, groupId: groupId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key: role2GroupStoreKey } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: groupId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'R2G',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                let permissions = [];
                const role2GroupData = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['role2GroupStore'](role2GroupStoreKey)));
                const responseRole2UserGroup = role2GroupData === null || role2GroupData === void 0 ? void 0 : role2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                if (responseRole2UserGroup.length > 0) {
                    for (const resRole2Group1 of responseRole2UserGroup) {
                        const responeFetchRolePermission = yield this.fetchRolePermissions({
                            owner,
                            roleId: resRole2Group1.role,
                        });
                        for (const resRole2Group2 of responeFetchRolePermission) {
                            const responseFetchPermission = yield this.fetchPermission({
                                owner,
                                permissionId: resRole2Group2.permission,
                            });
                            permissions.push(responseFetchPermission);
                        }
                    }
                    return permissions;
                }
                else {
                    throw new Error(`No permission is found with this groupId: ${groupId}`);
                }
            }
            catch (error) {
                throw new Error(`Error occurred while fetching group permission: ${error}`);
            }
        });
    }
    /**
     * Fetch all group roles.
     * @param option - The option for fetch group roles.
     * @returns A promise that resolves when the group roles is fetched.
     */
    fetchGroupRoles(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, groupId, wssBaseUrl = '' } = option;
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchGroupRoles({ owner: owner, groupId: groupId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: groupId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'R2G',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const role2GroupData = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['role2GroupStore'](hashed_key)));
                const responseRole2Group = role2GroupData === null || role2GroupData === void 0 ? void 0 : role2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return responseRole2Group;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching group roles: ${error}`);
            }
        });
    }
    /**
     * Fetches all of the groups this user address has
     *
     * @param FetchGroups - The parameters this function is expecting:
     *      @param owner - Address that owns all of the groups.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchGroups(options) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, wssBaseUrl = '' } = options;
                if (!owner)
                    throw new Error('Invalid owner address');
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchGroups({ owner: owner, wssBaseUrl: wssBaseUrl });
                }
                const api = this._getApi();
                const groups = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['groupStore'](owner)));
                if (!groups) {
                    throw new Error(`No group is found of owner: ${owner}`);
                }
                const responseData = groups === null || groups === void 0 ? void 0 : groups.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return responseData;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching groups: ${error}`);
            }
        });
    }
    /**
     * Fetches the permission for the owner at the permissionId.
     *
     * @param FetchPermission - The parameters this function is expecting:
     *      @param owner - Address that owns this particular permission.
     *      @param permissionId? - Specific permission identifier that will be fetched.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchPermission(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, permissionId, wssBaseUrl = '' } = option;
                this._validateInput(permissionId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!owner)
                        throw new Error("Address is required when reading an EVM transaction since an Account is never stored from seed.");
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchPermission({ owner: owner, permissionId: permissionId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: permissionId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'Permission',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const permission = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['keysLookUpStore'](hashed_key)));
                const { id, name, enabled } = JSON.parse(JSON.stringify(permission.toHuman()));
                return {
                    id,
                    name,
                    enabled,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while fetching group roles: ${error}`);
            }
        });
    }
    /**
     * Fetches all of the permissions this user address has
     *
     * @param FetchPermissions- The parameters this function is expecting:
     *      @param owner - Address that owns all of the permissions.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchPermissions(options) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, wssBaseUrl = '' } = options;
                if (!owner)
                    throw new Error('Invalid owner address');
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchPermissions({ owner: owner, wssBaseUrl: wssBaseUrl });
                }
                const api = this._getApi();
                const permissions = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['permissionStore'](owner)));
                if (!permissions) {
                    throw new Error(`No permission is found of owner: ${owner}`);
                }
                const responseData = permissions === null || permissions === void 0 ? void 0 : permissions.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return responseData;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching permissions: ${error}`);
            }
        });
    }
    /**
     * Fetches the Role for the owner at the roleId.
     *
     * @param FetchRole - The parameters this function is expecting:
     *      @param owner - Address that owns this particular role.
     *      @param roleId? - Specific role identifier that will be fetched.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchRole(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, roleId, wssBaseUrl = '' } = option;
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!owner)
                        throw new Error("Address is required when reading an EVM transaction since an Account is never stored from seed.");
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchRole({ owner: owner, roleId: roleId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: roleId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'Role',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const role = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['keysLookUpStore'](hashed_key)));
                const { id, name, enabled } = JSON.parse(JSON.stringify(role.toHuman()));
                if (!name) {
                    throw new Error(`Permission not exits with this owner address = ${owner}`);
                }
                return {
                    id,
                    name,
                    enabled,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while fetching role: ${error}`);
            }
        });
    }
    /**
     * Fetch all role permissions.
     * @param option - The option for fetch role permission.
     * @returns A promise that resolves when the permission of role is fetched.
     */
    fetchRolePermissions(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, roleId, wssBaseUrl = '' } = option;
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchRolePermissions({ owner: owner, roleId: roleId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: roleId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'P2R',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const rolePermissions = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['permission2RoleStore'](hashed_key)));
                if (!rolePermissions)
                    throw new Error(`Permission not exits with this roleId = ${roleId}`);
                const responeRolePermission = rolePermissions === null || rolePermissions === void 0 ? void 0 : rolePermissions.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return responeRolePermission;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching role permission: ${error}`);
            }
        });
    }
    /**
     * Fetch all user groups.
     * @param option - The option for fetch user groups.
     * @returns A promise that resolves when the user groups is fetched.
     */
    fetchUserGroups(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, userId, wssBaseUrl = '' } = option;
                this._validateInput(userId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchUserGroups({ owner: owner, userId: userId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: userId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'U2G',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const userGroups = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['user2GroupStore'](hashed_key)));
                if (!userGroups) {
                    throw new Error(`No group is assigned to this user`);
                }
                const response = userGroups === null || userGroups === void 0 ? void 0 : userGroups.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                return response;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching user groups: ${error}`);
            }
        });
    }
    /**
     * Fetch all user permissions.
     * @param option - The option for fetch user permissions.
     * @returns A promise that resolves when the user permissions is fetched.
     */
    fetchUserPermissions(option) {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, userId, wssBaseUrl = '' } = option;
                this._validateInput(userId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchUserPermissions({ owner: owner, userId: userId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key: Role2User_Key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: userId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'R2U',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const { hashed_key: User2Group_Key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: userId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'U2G',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const permissions = [];
                const processed_roles = [];
                // Role2User
                const role2userData = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['role2UserStore'](Role2User_Key)));
                const responseRole2User = role2userData === null || role2userData === void 0 ? void 0 : role2userData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                for (const resRole2User1 of responseRole2User) {
                    processed_roles.push(resRole2User1.role);
                    const responseFetchPermission = yield this.fetchRolePermissions({
                        owner,
                        roleId: resRole2User1.role,
                    });
                    for (const resRole2User2 of responseFetchPermission) {
                        const responseFetchPermission = yield this.fetchPermission({
                            owner,
                            permissionId: resRole2User2.permission,
                        });
                        permissions.push(responseFetchPermission);
                    }
                }
                // User2Group
                const user2GroupData = (yield ((_e = (_d = api.query) === null || _d === void 0 ? void 0 : _d['peaqRbac']) === null || _e === void 0 ? void 0 : _e['user2GroupStore'](User2Group_Key)));
                const responseUser2Group = user2GroupData === null || user2GroupData === void 0 ? void 0 : user2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                if (responseUser2Group.length === 0) {
                    return permissions;
                }
                for (const resUser2Group1 of responseUser2Group) {
                    const responseFetchGroupRoles = yield this.fetchGroupRoles({
                        owner,
                        groupId: resUser2Group1.group,
                    });
                    for (const resUser2Group2 of responseFetchGroupRoles) {
                        if (processed_roles.indexOf(resUser2Group2.role) === -1) {
                            const responseFetchPermission = yield this.fetchRolePermissions({
                                owner,
                                roleId: resUser2Group2.role,
                            });
                            for (const resUser2Group3 of responseFetchPermission) {
                                const responseFetchPermission = yield this.fetchPermission({
                                    owner,
                                    permissionId: resUser2Group3.permission,
                                });
                                permissions.push(responseFetchPermission);
                            }
                        }
                    }
                }
                return permissions;
            }
            catch (error) {
                throw new Error(`Error occurred while fetching user permissions: ${error}`);
            }
        });
    }
    /**
     * Fetch all user roles.
     * @param option - The option for fetch user roles.
     * @returns A promise that resolves when the user roles is fetched.
     */
    fetchUserRoles(option) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { owner, userId, wssBaseUrl = '' } = option;
                this._validateInput(userId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    if (!wssBaseUrl)
                        throw new Error("Need to provide a wss url for the chain you plan to read from.");
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.fetchUserRoles({ owner: owner, userId: userId, wssBaseUrl: wssBaseUrl });
                }
                const api = yield this._getApi();
                const { hashed_key } = (0, utils_1.createStorageKeys)([
                    {
                        value: owner,
                        type: types_1.CreateStorageKeysEnum.ADDRESS,
                    },
                    {
                        value: userId,
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                    {
                        value: 'R2U',
                        type: types_1.CreateStorageKeysEnum.STANDARD,
                    },
                ]);
                const role2userData = (yield ((_c = (_b = api.query) === null || _b === void 0 ? void 0 : _b['peaqRbac']) === null || _c === void 0 ? void 0 : _c['role2UserStore'](hashed_key)));
                const responseRole2User = role2userData === null || role2userData === void 0 ? void 0 : role2userData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
                if (responseRole2User.length === 0) {
                    throw new Error(`No role is assigned to this userId: ${userId}`);
                }
                else {
                    return responseRole2User;
                }
            }
            catch (error) {
                throw new Error(`Error occurred while fetching user roles: ${error}`);
            }
        });
    }
    /**
     * Unassign permission to role.
     * @param option - The option for unassign permission to role.
     * @returns A promise that resolves when the permission is unassign to role.
     */
    unassignPermissionToRole(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { permissionId, roleId, address = '', seed = '' } = option;
                this._validateInput(permissionId);
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.unassignPermissionToRole({ permissionId: permissionId, roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const unassignPermissionToRoleExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['unassignPermissionToRole']((0, util_1.stringToU8a)(permissionId), (0, util_1.stringToU8a)(roleId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: unassignPermissionToRoleExtrinsics,
                });
                return {
                    message: `Successfully unassign role: ${roleId} from permission: ${permissionId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while unassign permission to role: ${error}`);
            }
        });
    }
    /** UPDATE
     *
     *
     * Unassign role to group.
     * @param option - The option for unassign role to group.
     * @returns A promise that resolves when the role is unassign to group.
     */
    unassignRoleToGroup(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { roleId, groupId, address = '', seed = '' } = option;
                this._validateInput(roleId);
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.unassignRoleToGroup({ roleId: roleId, groupId: groupId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const unassignRoleToGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['unassignRoleToGroup']((0, util_1.stringToU8a)(roleId), (0, util_1.stringToU8a)(groupId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: unassignRoleToGroupExtrinsics,
                });
                return {
                    message: `Successfully unassign role: ${roleId} from group: ${groupId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while unassign role to group: ${error}`);
            }
        });
    }
    /**
     * Unassign role to user.
     * @param option - The option for unassign role to user.
     * @returns A promise that resolves when the role is unassign to user.
     */
    unassignRoleToUser(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, roleId, address = '', seed = '' } = option;
                this._validateInput(userId);
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.unassignRoleToUser({ roleId: roleId, userId: userId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const unassignRoleToUserExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['unassignRoleToUser']((0, util_1.stringToU8a)(roleId), (0, util_1.stringToU8a)(userId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: unassignRoleToUserExtrinsics,
                });
                return {
                    message: `Successfully unassign user: ${userId} from role: ${roleId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while unassign role to user: ${error}`);
            }
        });
    }
    /**
     * UPDATE
     *
     * Unassign user to group.
     * @param option - The option for unassign user to group.
     * @returns A promise that resolves when the user is unassign to group.
     */
    unassignUserToGroup(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { userId, groupId, address = '', seed = '' } = option;
                this._validateInput(userId);
                this._validateInput(groupId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.unassignUserToGroup({ userId: userId, groupId: groupId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const unassignUserToGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['unassignUserToGroup']((0, util_1.stringToU8a)(userId), (0, util_1.stringToU8a)(groupId));
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: unassignUserToGroupExtrinsics,
                });
                return {
                    message: `Successfully unassign user: ${userId} from group: ${groupId}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while unassign role to user: ${error}`);
            }
        });
    }
    /**
     * Update the group.
     * @param option - The option for update the group.
     * @returns A promise that resolves when the group is updated.
     */
    updateGroup(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { groupName, groupId, address = '', seed = '' } = option;
                if (!groupName)
                    throw new Error('Name is required');
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.updateGroup({ groupName: groupName, groupId: groupId });
                }
                this._validateInput(groupId);
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const updateGroupExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['updateGroup']((0, util_1.stringToU8a)(groupId), groupName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: updateGroupExtrinsics,
                });
                return {
                    message: `Successfully update group ${groupId} with new name: ${groupName}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while update group: ${error}`);
            }
        });
    }
    /**
     * Update the permission.
     * @param option - The option for update the permission.
     * @returns A promise that resolves when the permission is updated.
     */
    updatePermission(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { permissionName, permissionId, address = '', seed = '' } = option;
                if (!permissionName)
                    throw new Error('Name is required');
                this._validateInput(permissionId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.updatePermission({ permissionName: permissionName, permissionId: permissionId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const updatePermissionExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['updatePermission']((0, util_1.stringToU8a)(permissionId), permissionName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: updatePermissionExtrinsics,
                });
                return {
                    message: `Successfully update permission ${permissionId} with new name: ${permissionName}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while update permission: ${error}`);
            }
        });
    }
    /**
     * Update the role.
     * @param option - The option for update the role.
     * @returns A promise that resolves when the role is updated.
     */
    updateRole(option) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { roleName, roleId, address = '', seed = '' } = option;
                if (!roleName)
                    throw new Error('Name is required');
                this._validateInput(roleId);
                if (((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.chainType) == types_2.ChainType.EVM) {
                    const evm = new evm_class_rbac_1.RbacClassEvm();
                    return yield evm.updateRole({ roleName: roleName, roleId: roleId });
                }
                const api = this._getApi();
                const keyPair = ((_b = this._metadata) === null || _b === void 0 ? void 0 : _b.pair) || this._getKeyPair(seed);
                const updateRoleExtrinsics = (_d = (_c = api.tx) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['updateRole']((0, util_1.stringToU8a)(roleId), roleName);
                const nonce = yield this._getNonce(address || keyPair.address);
                yield this._newSignTx({
                    nonce,
                    address: keyPair,
                    extrinsics: updateRoleExtrinsics,
                });
                return {
                    message: `Successfully update role ${roleId} with new name: ${roleName}`,
                };
            }
            catch (error) {
                throw new Error(`Error occurred while update role: ${error}`);
            }
        });
    }
}
exports.RBAC = RBAC;
//# sourceMappingURL=index.js.map
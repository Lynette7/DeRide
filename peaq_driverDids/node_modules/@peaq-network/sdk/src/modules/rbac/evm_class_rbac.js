"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RbacClassEvm = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const types_1 = require("../../types");
const types_2 = require("../../../../types");
const util_crypto_1 = require("@polkadot/util-crypto");
const utils_1 = require("../../utils");
const api_1 = require("@polkadot/api");
const util_1 = require("@polkadot/util");
var FunctionSignatures;
(function (FunctionSignatures) {
    FunctionSignatures["ADD_ROLE"] = "addRole(bytes32,bytes)";
    FunctionSignatures["ADD_GROUP"] = "addGroup(bytes32,bytes)";
    FunctionSignatures["ADD_PERMISSION"] = "addPermission(bytes32,bytes)";
    FunctionSignatures["ASSIGN_PERMISSION_TO_ROLE"] = "assignPermissionToRole(bytes32,bytes32)";
    FunctionSignatures["UNASSIGN_PERMISSION_TO_ROLE"] = "unassignPermissionToRole(bytes32,bytes32)";
    FunctionSignatures["ASSIGN_ROLE_TO_GROUP"] = "assignRoleToGroup(bytes32,bytes32)";
    FunctionSignatures["UNASSIGN_ROLE_TO_GROUP"] = "unassignRoleToGroup(bytes32,bytes32)";
    FunctionSignatures["ASSIGN_ROLE_TO_USER"] = "assignRoleToUser(bytes32,bytes32)";
    FunctionSignatures["UNASSIGN_ROLE_TO_USER"] = "unassignRoleToUser(bytes32,bytes32)";
    FunctionSignatures["ASSIGN_USER_TO_GROUP"] = "assignUserToGroup(bytes32,bytes32)";
    FunctionSignatures["UNASSIGN_USER_TO_GROUP"] = "unassignUserToGroup(bytes32,bytes32)";
    FunctionSignatures["DISABLE_GROUP"] = "disableGroup(bytes32)";
    FunctionSignatures["DISABLE_PERMISSION"] = "disablePermission(bytes32)";
    FunctionSignatures["DISABLE_ROLE"] = "disableRole(bytes32)";
    FunctionSignatures["UPDATE_GROUP"] = "updateGroup(bytes32,bytes)";
    FunctionSignatures["UPDATE_PERMISSION"] = "updatePermission(bytes32,bytes)";
    FunctionSignatures["UPDATE_ROLE"] = "updateRole(bytes32,bytes)";
})(FunctionSignatures || (FunctionSignatures = {}));
var PrecompileAddresses;
(function (PrecompileAddresses) {
    PrecompileAddresses["DID"] = "0x0000000000000000000000000000000000000802";
})(PrecompileAddresses || (PrecompileAddresses = {}));
class RbacClassEvm {
    constructor() {
        this.abiCoder = new ethers_1.ethers.AbiCoder();
    }
    /**
     * Creates a new role of the given name at the role id.
     *
     * @param CreateRole - The parameters this function is expecting:
     *      @param roleName - Name of the role that is created
     *      @param roleId - Generate/user created role ID that acts as the key
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createRole(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { roleName, roleId } = options;
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const createRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ADD_ROLE)).substring(0, 10);
            const roleNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(roleName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedRoleId, roleNameBytes]);
            let payload = params.replace("0x", createRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    updateRole(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { roleName, roleId } = options;
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const updateRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UPDATE_ROLE)).substring(0, 10);
            const roleNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(roleName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedRoleId, roleNameBytes]);
            let payload = params.replace("0x", updateRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    disableRole(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { roleId } = options;
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const disableRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.DISABLE_ROLE)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32"], [convertedRoleId]);
            let payload = params.replace("0x", disableRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    assignRoleToGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { groupId, roleId } = options;
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const assignRoleToGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ASSIGN_ROLE_TO_GROUP)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedRoleId, convertedGroupId]);
            let payload = params.replace("0x", assignRoleToGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    unassignRoleToGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { groupId, roleId } = options;
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const unassignPermissionToRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UNASSIGN_ROLE_TO_GROUP)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedRoleId, convertedGroupId]);
            let payload = params.replace("0x", unassignPermissionToRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    assignRoleToUser(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { userId, roleId } = options;
            const convertedUserId = (0, util_1.stringToU8a)(userId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const assignRoleToGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ASSIGN_ROLE_TO_USER)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedRoleId, convertedUserId]);
            let payload = params.replace("0x", assignRoleToGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    unassignRoleToUser(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { userId, roleId } = options;
            const convertedUserId = (0, util_1.stringToU8a)(userId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const unassignRoleToGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UNASSIGN_ROLE_TO_USER)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedRoleId, convertedUserId]);
            let payload = params.replace("0x", unassignRoleToGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Creates a new group within the RBAC system.
     *
     * @param CreateGroup - The parameters this function is expecting:
     *      @param groupName - Name of the group that is created
     *      @param groupId - Generate/user created group ID that acts as the key
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { groupName, groupId } = options;
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const createGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ADD_GROUP)).substring(0, 10);
            const groupNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(groupName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedGroupId, groupNameBytes]);
            let payload = params.replace("0x", createGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    updateGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { groupName, groupId } = options;
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const updateGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UPDATE_GROUP)).substring(0, 10);
            const groupNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(groupName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedGroupId, groupNameBytes]);
            let payload = params.replace("0x", updateGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    disableGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { groupId } = options;
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const disableGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.DISABLE_GROUP)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32"], [convertedGroupId]);
            let payload = params.replace("0x", disableGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Creates a new permission within the RBAC system.
     *
     * @param CreatePermission - The parameters this function is expecting:
     *      @param permissionName - Name of the permission that is created
     *      @param permissionId - Generate/user created group ID that acts as the key
     * @returns tx - The transaction object for add item that a user can send manually.
     */
    createPermission(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { permissionName, permissionId } = options;
            const convertedPermissionId = (0, util_1.stringToU8a)(permissionId);
            const createPermissionFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ADD_PERMISSION)).substring(0, 10);
            const permissionNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(permissionName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedPermissionId, permissionNameBytes]);
            let payload = params.replace("0x", createPermissionFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    updatePermission(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { permissionName, permissionId } = options;
            const convertedPermissionId = (0, util_1.stringToU8a)(permissionId);
            const updatePermissionFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UPDATE_PERMISSION)).substring(0, 10);
            const permissionNameBytes = ethers_1.ethers.hexlify(ethers_1.ethers.toUtf8Bytes(permissionName));
            const params = this.abiCoder.encode(["bytes32", "bytes"], [convertedPermissionId, permissionNameBytes]);
            let payload = params.replace("0x", updatePermissionFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    disablePermission(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { permissionId } = options;
            const convertedPermissionId = (0, util_1.stringToU8a)(permissionId);
            const disablePermissionFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.DISABLE_PERMISSION)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32"], [convertedPermissionId]);
            let payload = params.replace("0x", disablePermissionFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    assignPermissionToRole(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { permissionId, roleId } = options;
            const convertedPermissionId = (0, util_1.stringToU8a)(permissionId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const assignPermissionToRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ASSIGN_PERMISSION_TO_ROLE)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedPermissionId, convertedRoleId]);
            let payload = params.replace("0x", assignPermissionToRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    unassignPermissionToRole(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { permissionId, roleId } = options;
            const convertedPermissionId = (0, util_1.stringToU8a)(permissionId);
            const convertedRoleId = (0, util_1.stringToU8a)(roleId);
            const unassignPermissionToRoleFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UNASSIGN_PERMISSION_TO_ROLE)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedPermissionId, convertedRoleId]);
            let payload = params.replace("0x", unassignPermissionToRoleFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    assignUserToGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { userId, groupId } = options;
            const convertedUserId = (0, util_1.stringToU8a)(userId);
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const assignUserToGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.ASSIGN_USER_TO_GROUP)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedUserId, convertedGroupId]);
            let payload = params.replace("0x", assignUserToGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    // TODO
    unassignUserToGroup(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { userId, groupId } = options;
            const convertedUserId = (0, util_1.stringToU8a)(userId);
            const convertedGroupId = (0, util_1.stringToU8a)(groupId);
            const unassignUserToGroupFunctionSelector = ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(FunctionSignatures.UNASSIGN_USER_TO_GROUP)).substring(0, 10);
            const params = this.abiCoder.encode(["bytes32", "bytes32"], [convertedUserId, convertedGroupId]);
            let payload = params.replace("0x", unassignUserToGroupFunctionSelector);
            const tx = {
                to: PrecompileAddresses.DID,
                data: payload
            };
            return tx;
        });
    }
    /**
     * Fetches the Role for the owner at the roleId.
     *
     * @param FetchRole - The parameters this function is expecting:
     *      @param owner - Address that owns this particular role.
     *      @param roleId - Specific role identifier that will be fetched.
     *      @param wssBaseUrl - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchRole(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, roleId, wssBaseUrl } = options;
            const rbacType = "Role";
            const storeQuery = 'keysLookUpStore';
            const hashedKey = yield this._storageDecoder(owner, roleId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const value = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            const { id, name, enabled } = JSON.parse(JSON.stringify(value.toHuman()));
            if (!name) {
                throw new Error(`${rbacType} not exits with this owner address = ${owner}`);
            }
            return { id, name, enabled };
        });
    }
    ;
    /**
     * Fetches all of the roles this user address has.
     *
     * @param FetchRoles - The parameters this function is expecting:
     *      @param owner - Address that owns all of the roles.
     *      @param wssBaseUrl - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchRoles(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, wssBaseUrl } = options;
            const substrateAddress = (0, util_crypto_1.evmToAddress)(owner);
            const api = yield this._getApiProvider(wssBaseUrl);
            const roles = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b['roleStore'](substrateAddress)));
            yield api.disconnect();
            if (!roles) {
                throw new Error(`Roles not exits with this owner address = ${owner}`);
            }
            const responseData = roles === null || roles === void 0 ? void 0 : roles.map((role) => JSON.parse(JSON.stringify(role.toHuman())));
            return responseData;
        });
    }
    ;
    // TODO
    fetchRolePermissions(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, roleId, wssBaseUrl } = options;
            const rbacType = "P2R";
            const storeQuery = 'permission2RoleStore';
            const hashedKey = yield this._storageDecoder(owner, roleId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const rolePermissions = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            if (!rolePermissions) {
                throw new Error(`Permission not exits with this roleId = ${roleId}`);
            }
            const responeRolePermission = rolePermissions === null || rolePermissions === void 0 ? void 0 : rolePermissions.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            return responeRolePermission;
        });
    }
    ;
    /**
     * Fetches the Group for the owner at the groupId.
     *
     * @param FetchGroup - The parameters this function is expecting:
     *      @param owner - Address that owns this particular group.
     *      @param groupId - Specific group identifier that will be fetched.
     *      @param wssBaseUrl - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchGroup(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, groupId, wssBaseUrl } = options;
            const rbacType = "Group";
            const storeQuery = 'keysLookUpStore';
            const hashedKey = yield this._storageDecoder(owner, groupId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const value = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            const { id, name, enabled } = JSON.parse(JSON.stringify(value.toHuman()));
            if (!name) {
                throw new Error(`${rbacType} not exits with this owner address = ${owner}`);
            }
            return { id, name, enabled };
        });
    }
    ;
    /**
     * Fetches all of the groups this user address has
     *
     * @param FetchGroups - The parameters this function is expecting:
     *      @param owner - Address that owns all of the groups.
     *      @param wssBaseUrl - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchGroups(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, wssBaseUrl } = options;
            const substrateAddress = (0, util_crypto_1.evmToAddress)(owner);
            const api = yield this._getApiProvider(wssBaseUrl);
            const groups = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b['groupStore'](substrateAddress)));
            yield api.disconnect();
            if (!groups) {
                throw new Error(`Groups do not exits with this owner address = ${owner}`);
            }
            const responseData = groups === null || groups === void 0 ? void 0 : groups.map((group) => JSON.parse(JSON.stringify(group.toHuman())));
            return responseData;
        });
    }
    ;
    // TODO
    fetchGroupRoles(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, groupId, wssBaseUrl } = options;
            const rbacType = 'R2G';
            const storeQuery = 'role2GroupStore';
            const hashedKey = yield this._storageDecoder(owner, groupId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const role2GroupData = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            if (!role2GroupData) {
                throw new Error(`Permission not exits with this groupId = ${groupId}`);
            }
            const responseRole2Group = role2GroupData === null || role2GroupData === void 0 ? void 0 : role2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            return responseRole2Group;
        });
    }
    ;
    /**
     * Fetches the permission for the owner at the permissionId.
     *
     * @param FetchPermission - The parameters this function is expecting:
     *      @param owner - Address that owns this particular permission.
     *      @param permissionId? - Specific permission identifier that will be fetched.
     *      @param wssBaseUrl? - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData - Object with the response.
     */
    fetchPermission(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, permissionId, wssBaseUrl } = options;
            const rbacType = "Permission";
            const storeQuery = 'keysLookUpStore';
            const hashedKey = yield this._storageDecoder(owner, permissionId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const value = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            const { id, name, enabled } = JSON.parse(JSON.stringify(value.toHuman()));
            if (!name) {
                throw new Error(`${rbacType} not exits with this owner address = ${owner}`);
            }
            return { id, name, enabled };
        });
    }
    ;
    /**
     * Fetches all of the permissions this user address has.
     *
     * @param FetchPermissions - The parameters this function is expecting:
     *      @param owner - Address that owns all of the permissions.
     *      @param wssBaseUrl - Endpoint url that connects to the blockchain to read from.
     * @returns FetchResponseData[] - Array of object with the responses.
     */
    fetchPermissions(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, wssBaseUrl } = options;
            const substrateAddress = (0, util_crypto_1.evmToAddress)(owner);
            const api = yield this._getApiProvider(wssBaseUrl);
            const permissions = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b['permissionStore'](substrateAddress)));
            yield api.disconnect();
            if (!permissions) {
                throw new Error(`Permission not exits with this owner address = ${owner}`);
            }
            const responseData = permissions === null || permissions === void 0 ? void 0 : permissions.map((permission) => JSON.parse(JSON.stringify(permission.toHuman())));
            return responseData;
        });
    }
    ;
    // TODO
    fetchUserRoles(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, userId, wssBaseUrl } = options;
            const rbacType = "R2U";
            const storeQuery = 'role2UserStore';
            const hashedKey = yield this._storageDecoder(owner, userId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const role2userData = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            const responseRole2User = role2userData === null || role2userData === void 0 ? void 0 : role2userData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            if (responseRole2User.length === 0) {
                throw new Error(`No role is assigned to this userId: ${userId}`);
            }
            else {
                return responseRole2User;
            }
        });
    }
    ;
    // TODO
    fetchUserGroups(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, userId, wssBaseUrl } = options;
            const rbacType = "U2G";
            const storeQuery = 'user2GroupStore';
            const hashedKey = yield this._storageDecoder(owner, userId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            // read did from store
            const userGroups = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b[storeQuery](hashedKey.hashed_key)));
            yield api.disconnect();
            if (!userGroups) {
                throw new Error(`No group is assigned to this user`);
            }
            const response = userGroups === null || userGroups === void 0 ? void 0 : userGroups.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            return response;
        });
    }
    ;
    // TODO
    fetchUserPermissions(options) {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, userId, wssBaseUrl } = options;
            const rbacType = "R2U";
            const Role2User_Key = yield this._storageDecoder(owner, userId, rbacType);
            const rbacType2 = "U2G";
            const User2Group_Key = yield this._storageDecoder(owner, rbacType2, rbacType);
            const permissions = [];
            const processed_roles = [];
            const api = yield this._getApiProvider(wssBaseUrl);
            // Role2User
            const role2userData = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b['role2UserStore'](Role2User_Key.hashed_key)));
            const responseRole2User = role2userData === null || role2userData === void 0 ? void 0 : role2userData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            for (const resRole2User1 of responseRole2User) {
                processed_roles.push(resRole2User1.role);
                const responseFetchPermission = yield this.fetchRolePermissions({
                    owner,
                    roleId: resRole2User1.role,
                    wssBaseUrl: wssBaseUrl
                });
                for (const resRole2User2 of responseFetchPermission) {
                    const responseFetchPermission = yield this.fetchPermission({
                        owner,
                        permissionId: resRole2User2.permission,
                        wssBaseUrl: wssBaseUrl
                    });
                    permissions.push(responseFetchPermission);
                }
            }
            // User2Group
            const user2GroupData = (yield ((_d = (_c = api.query) === null || _c === void 0 ? void 0 : _c['peaqRbac']) === null || _d === void 0 ? void 0 : _d['user2GroupStore'](User2Group_Key.hashed_key)));
            const responseUser2Group = user2GroupData === null || user2GroupData === void 0 ? void 0 : user2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            if (responseUser2Group.length === 0) {
                yield api.disconnect();
                return permissions;
            }
            for (const resUser2Group1 of responseUser2Group) {
                const responseFetchGroupRoles = yield this.fetchGroupRoles({
                    owner,
                    groupId: resUser2Group1.group,
                    wssBaseUrl: wssBaseUrl
                });
                for (const resUser2Group2 of responseFetchGroupRoles) {
                    if (processed_roles.indexOf(resUser2Group2.role) === -1) {
                        const responseFetchPermission = yield this.fetchRolePermissions({
                            owner,
                            roleId: resUser2Group2.role,
                            wssBaseUrl: wssBaseUrl
                        });
                        for (const resUser2Group3 of responseFetchPermission) {
                            const responseFetchPermission = yield this.fetchPermission({
                                owner,
                                permissionId: resUser2Group3.permission,
                                wssBaseUrl: wssBaseUrl
                            });
                            permissions.push(responseFetchPermission);
                        }
                    }
                }
            }
            yield api.disconnect();
            return permissions;
        });
    }
    ;
    // TODO
    fetchGroupPermissions(options) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { owner, groupId, wssBaseUrl } = options;
            const rbacType = "R2G";
            const hashedKey = yield this._storageDecoder(owner, groupId, rbacType);
            const api = yield this._getApiProvider(wssBaseUrl);
            let permissions = [];
            const role2GroupData = (yield ((_b = (_a = api.query) === null || _a === void 0 ? void 0 : _a['peaqRbac']) === null || _b === void 0 ? void 0 : _b['role2GroupStore'](hashedKey.hashed_key)));
            const responseRole2UserGroup = role2GroupData === null || role2GroupData === void 0 ? void 0 : role2GroupData.map((item) => JSON.parse(JSON.stringify(item.toHuman())));
            if (responseRole2UserGroup.length > 0) {
                for (const resRole2Group1 of responseRole2UserGroup) {
                    const responeFetchRolePermission = yield this.fetchRolePermissions({
                        owner,
                        roleId: resRole2Group1.role,
                        wssBaseUrl: wssBaseUrl
                    });
                    for (const resRole2Group2 of responeFetchRolePermission) {
                        const responseFetchPermission = yield this.fetchPermission({
                            owner,
                            permissionId: resRole2Group2.permission,
                            wssBaseUrl: wssBaseUrl
                        });
                        permissions.push(responseFetchPermission);
                    }
                }
                yield api.disconnect();
                return permissions;
            }
            else {
                throw new Error(`No permission is found with this groupId: ${groupId}`);
            }
        });
    }
    ;
    _storageDecoder(address, rbacId, rbacType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Convert EVM to Substrate address
            const substrateAddress = (0, util_crypto_1.evmToAddress)(address);
            return (0, utils_1.createStorageKeys)([
                {
                    value: substrateAddress,
                    type: types_1.CreateStorageKeysEnum.ADDRESS,
                },
                {
                    value: rbacId,
                    type: types_1.CreateStorageKeysEnum.STANDARD,
                },
                {
                    value: rbacType,
                    type: types_1.CreateStorageKeysEnum.STANDARD,
                },
            ]);
        });
    }
    _getApiProvider(wssBaseUrl) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!wssBaseUrl)
                    throw new Error("Need to provide a wss url for the chain you plan to read from.");
                const wsp = new api_1.WsProvider(wssBaseUrl);
                var api = yield (yield api_1.ApiPromise.create(Object.assign({ provider: wsp, noInitWarn: true }, types_2.defaultOptions))).isReady;
                return api;
            }
            catch (error) {
                throw new Error(`WSS base url of ${wssBaseUrl}, is not valid with error message: ${error}`);
            }
        });
    }
    /**
     * Used to validate a proper H160 address is being passed.
     */
    _checkEvmAddress(address) {
        if (!ethers_1.ethers.isAddress(address)) {
            throw new Error(`${address} is not a valid EVM address`);
        }
    }
}
exports.RbacClassEvm = RbacClassEvm;
//# sourceMappingURL=evm_class_rbac.js.map